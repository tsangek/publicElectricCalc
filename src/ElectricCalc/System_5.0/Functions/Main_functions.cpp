#include "Main_system.h"

//——————————————————————————————————————————————————————————————————————————————
//Программа решения системы линенйных уравнений A*f = b
//——————————————————————————————————————————————————————————————————————————————
int Solve_lin_system(
int Rebro_kol,         //кол-во уравнений
double *vector_b,      //вектор правой части СЛАУ - b
double **matrix_a,     //матрица СЛАУ - A
double *vector_f,      //вектор переменных СЛАУ - f
bool pr_print,         //параметр печати матрицы в файл
FILE *f)               //файл для печати матрицы
{
	int i,j;           //счётчики

	using namespace alglib;
	//--------------------------
	//создание матриц alglib для решения СЛАУ
	real_2d_array Ubl_matrix_a; 	Ubl_matrix_a.setlength(Rebro_kol,Rebro_kol);  //матрица СЛАУ - A
	real_2d_array Ubl_matrix_a_1; 	Ubl_matrix_a_1.setlength(Rebro_kol,Rebro_kol);//обратная матрица СЛАУ - A_1
	real_2d_array Ubl_vector_b; 	Ubl_vector_b.setlength(Rebro_kol,1);          //вектор правой части СЛАУ - b
	real_2d_array Ubl_vector_f; 	Ubl_vector_f.setlength(Rebro_kol,1);          //вектор переменных СЛАУ - f

	//--------------------------
	//переписывание данных в новые матрицы alglib из класических матриц
	for (i = 0; i < Rebro_kol; i++)
	{
	Ubl_vector_b(i,0) = vector_b[i];

	for (j = 0; j < Rebro_kol; j++)
	{
		Ubl_matrix_a(i,j) = matrix_a[i][j];
	}
	}

	//--------------------------
	//печать матрицыСЛАУ и векторы правой части, если параметр мечати - истина
	if(pr_print)
	{
	for(i = 0; i < Rebro_kol; i++)
	{
		for(j = 0; j < Rebro_kol; j++)
		{
			fprintf(f,"%7.10f\t",Ubl_matrix_a(i,j));
		}
		fprintf(f,"\n");
	}
	fprintf(f,"\n");
	fprintf(f,"\n");
	for(i = 0; i < Rebro_kol; i++)
	{
		fprintf(f,"%7.10f\t",Ubl_vector_b(i,0));
	}
	fprintf(f,"\n");
	fprintf(f,"\n");
	}

	//--------------------------
	Ubl_matrix_a_1 = Ubl_matrix_a;    //копирование матрицы для её обращения
	ae_int_t info;                    //переменная результата обращения
	matinvreport rep;                 //переменная отчёта об обращении
	rmatrixinverse(Ubl_matrix_a_1, info, rep);  //обращение матрицы

	//--------------------------
	//Умножение обратной матриц на вектор правой части.
	//Функция имеет вид a*A*B + b*C, поэтому даже простая операция массивна.
	//Параметры: уникальный размер A, уникальный размер B, общий размер A и B,
	//коэф. a, ссылка на A, 3 параметра трансформации A, ссылка на B, 3 параметра трансформации B,
	//коэф. b(если b = 0, то данные по C не нужны),ссылка на С, 2 параметра трансформации С)
	rmatrixgemm(
		Rebro_kol, 1, Rebro_kol,
		1.0,
		Ubl_matrix_a_1, 0, 0, 0,
		Ubl_vector_b, 0, 0, 0,
		0.0,
		Ubl_vector_f, 0, 0);

	//--------------------------
	//запись вектора решения в обычный вектор
	for (i = 0; i < Rebro_kol; i++)
	{
	vector_f[i] = Ubl_vector_f(i,0);
	}

return 0;
}  //конец функции решения системы уравнений

//——————————————————————————————————————————————————————————————————————————————
//функция поиска замкнутых независимых крнтуров на графе
//——————————————————————————————————————————————————————————————————————————————
int Find_kontur_array(
int Rebro_kol,           //количество рёбер
int Uzel_kol,            //количество узлов
int *kluch_kombo,        //указатель на массив комбинации ключей
int *kluch_kombo_mod,    //указатель на обработанный массив комбинации ключей
Class_Uzel_Elektrik **Class_Uzel,     //указатель на массив узлов
Class_Rebro_Elektrik **Class_Rebro,   //указатель на массив рёбер
Kontur *Kontur_local,                 //указатель на класс анализа графов
FILE *f,                              //файл для печати
bool pr_print)
{
	int i,j;        //счётчики
	int Kluch_kol;  //счётчик количества отключённых рёбер

	//--------------------------
	//Отключение рёбер
	Kluch_kol = Rebro_kol;            //инициализация кол-ва ключей кол-вом рёбер, т.е. все разомкнуты
	for (i = 0; i < Rebro_kol; i++)   //перебор всех рёбер
	{
		Class_Rebro[i]->pr_diod_nonst=0;    //все ключи разомкнуты
	}

	for (i = 0; i < Rebro_kol; i++)        //перебор всех рёбер
	{
		if(kluch_kombo[i]==1)       //замыкаем все ключи, в соответствии с условием
		{
		Class_Rebro[i]->pr_diod_nonst=1;  //замыкаем ключ
		Kluch_kol--;                      //декримент счётчика разомкнутых ключей
		}
	}

	//--------------------------
	//Активация классов узлов
	for (i = 0; i < Uzel_kol; i++)      //перебор по всем узлам
	{
		//отключённые рёбра не учавствуют в инициализации класса узлов
		Class_Uzel[i]->Ini(Class_Rebro, Class_Uzel, i,
				Rebro_kol, Rebro_kol-Kluch_kol);
	}

	//——————————————————————————————————————————————————————————————————————————————
	//поиск замкнутых независимых контуров
	//инициализация начальных данных для поиска (конфигурация графа)
	Kontur_local->Ini(Class_Uzel,Class_Rebro,Uzel_kol,Rebro_kol,Kluch_kol);

	Kontur_local->Start_all();   //начало поиска

	if (pr_print) {
	Kontur_local->fprint_kontur(f);    //печать найденых контуров
	fprintf(f,"\n");
	}


	//--------------------------
	//поиск рёбер, которые оказались отрезанными из контура, т.е. не входящих
	//ни в один замкнутый контур. Формирование новой комбинации ключей без
	//подобных "отрезанных" рёбер
	Kontur_local->Find_cut_wires(kluch_kombo_mod); //поиск рёбер, которые

	//——————————————————————————————————————————————————————————————————————————————
	//Активация классов узлов

	//--------------------------
	//Отключение рёбер
	Kluch_kol = Rebro_kol;            //инициализация кол-ва ключей кол-вом рёбер, т.е. все разомкнуты
	for (i = 0; i < Rebro_kol; i++)   //перебор всех рёбер
	{
		Class_Rebro[i]->pr_diod_nonst=0;    //все ключи разомкнуты
	}

	for (i = 0; i < Rebro_kol; i++)        //перебор всех рёбер
	{
		if(kluch_kombo_mod[i]==1)       //замыкаем все ключи, в соответствии с условием
		{
		Class_Rebro[i]->pr_diod_nonst=1;  //замыкаем ключ
		Kluch_kol--;                      //декримент счётчика разомкнутых ключей
		}
	}

	//--------------------------
	//Активация классов узлов
	for (i = 0; i < Uzel_kol; i++)      //перебор по всем узлам
	{
		//отключённые рёбра не учавствуют в инициализации класса узлов
		Class_Uzel[i]->Ini(Class_Rebro, Class_Uzel, i,
				Rebro_kol, Rebro_kol-Kluch_kol);

	}

	//-----------------------------------------
	//Во всех несвязных цепях назначаются по одному узлу начала, среди узлов входящих в
	//независимые замкнутые контура
	Kontur_local->Ini(Class_Uzel,Class_Rebro,Uzel_kol,Rebro_kol,Kluch_kol);
	Kontur_local->Start_all();   //начало поиска
	Kontur_local->Find_Uzel_svjaz();
//	Kontur_local->fprint_znak(f);     //печать направлений обхода рёбер в найденных контурах
//	fprintf(f,"\n");

return 0;
}   //конец функции поиска замкнутых независимых крнтуров на графе

//——————————————————————————————————————————————————————————————————————————————
//Функция создания и решения матрицы СЛАУ Кирхгофа ( A*f = b)
//——————————————————————————————————————————————————————————————————————————————
int Make_lin_system(
int Rebro_kol,       //количество рёбер
int Uzel_kol,        //количество узлов
double *vector_b,    //вектор правой части СЛАУ - b
double **matrix_a,   //матрица СЛАУ - A
double *vector_f,    //вектор переменных СЛАУ - f
Class_Uzel_Elektrik **Class_Uzel,   //указатель на массив узлов
Class_Rebro_Elektrik **Class_Rebro, //указатель на массив рёбер
Kontur *Kontur_Arr,   //указатель на класс анализа графов и независимых контуров
int *kluch_kombo,     //указатель на обработанный массив комбинации ключей
FILE *f,              //файл для печати
bool pr_print)        //параметр печати
{
int i,j;              //счётчики
int ier;              //номер ошибки
int sign_U;           //знак, характеризующий направление ребра при обходе по контуру
int Rebro_num;        //номер обрабатываемого ребра
int Uzel_active_kol;  //количество активных узлов( ранг которых больше 0, вообще говори больше 1, т.к. не может быть в замкнутом контуре узла с рангом 0)
int offset;           //переменная сдвига нумерации при преобразовании матриц

//--------------------------
//поиск количества отключенных рёбер
int	Kluch_kol = 0;    //инициализация счётчика
for (j = 0; j < Rebro_kol; j++)  //перебор всех рёбер
{
	if(kluch_kombo[j] == 0)      //заходим, если ребро отключено
	{
		Kluch_kol++;             //инкримент счётчика
	}
}

//--------------------------
//создание массивов для записи обработанных данных - т.е. без отключенных
//рёбер и узлов
int Rebro_kol_mod = Rebro_kol-Kluch_kol;  //количество неотключённых рёбер

double **matrix_a_mod = new double *[Rebro_kol_mod];
for (i = 0; i < Rebro_kol_mod; i++)
{
	matrix_a_mod[i] = new double [Rebro_kol_mod];
}

double *vector_b_mod = new double [Rebro_kol_mod];
double *vector_f_mod = new double [Rebro_kol_mod];

//--------------------------
//инициализация массивов нулями
for (i = 0; i < Rebro_kol; i++)
{
	vector_b[i] = (double) 0.0;
	vector_f[i] = (double) 0.0;

	for (j = 0; j < Rebro_kol; j++)
	{
	matrix_a[i][j] = (double) 0.0;
	}
}

//——————————————————————————————————————————————————————————————————————————————
//создание НЕквадратной (необработанной) матрицы
//--------------------------
//уравнения баланса токов в узлах
Uzel_active_kol=0;   //инициализация счётчика активных узлов нулём
for (i = 0; i < Uzel_kol; i++) //перебор узлов
{
	if(Class_Uzel[i]->Rang_uzla==0) continue;    //если ранг узла равен 0 - пропуск

	//для каждого замкнутого контура баланс токов в узлах надо написать для всех
	//узлов, кроме одного. Выбор узла не так очевиден, так как много узлов гасятся,
	//и надо именно по одному узлу из контура. Поиском таких узлов занимается класс Kontur
	//при вызове из функции Find_kolntur_array.
	if(Kontur_Arr->Uzel_propusk[i]==1) continue;   //пропуск одного узла из замкнутого контура

	//запись уравнений баланса токов в узлах: a0*I0 + a1*I1 + ... + ai*Ii = 0
	// ai равно 0, если ребро не соеденино с данным узлом,
	// ai равно 1 - если данный узел - вход ребра,
	// ai равно -1 - если данный узел - выход ребра.
	ier = Class_Uzel[i]->Rash_vector_a_and_b(matrix_a[Uzel_active_kol],&vector_b[Uzel_active_kol]);
	Uzel_active_kol++;    //инкремент количества активных узлов
}

//--------------------------
//Напряжение при обходе контура
//--------------------------
//Всего ранг матрицы равен кол-ву активных рёбер. Уравнения с номера
//кол-ва активных узлов и вплоть до кол-ва активных рёбер - это уравнения
//падения напряжения при обходе контура.
for (i = Uzel_active_kol; i < Rebro_kol_mod; i++)
{
	//Перебор по всем рёбрам в данном замкнутом контуре. Их кол-во смотрится
	//в классе Kontur.
	for (j = 0; j < Kontur_Arr->Rangy[i-Uzel_active_kol]; j++)
	{
	Rebro_num = Kontur_Arr->Kontury[i-Uzel_active_kol][j][0]; //номер расматриемого ребра

	//определение знака при обходе из класса Kontur
	(Kontur_Arr->Kontury[i-Uzel_active_kol][j][1])? sign_U=1:sign_U=-1;

	//запись в матрицу СЛАУ на соответственную позицию для данного ребра его
	//коэф. А и B (U = A*I + B). Из коэф. A состовляется матрица СЛАУ,
	//а из коэф. B - вектор правых частей.
	matrix_a[i][Rebro_num] = matrix_a[i][Rebro_num] + (double)sign_U*Class_Rebro[Rebro_num]->A_nonst;
	vector_b[i] = vector_b[i] - (double)sign_U*Class_Rebro[Rebro_num]->B_nonst;
	}
}

//——————————————————————————————————————————————————————————————————————————————
//Преобразование матрицы к квадратной, путём удаления столбцов неактивных рёбер.
//количество строк уже правильное исходя из кол-ва активных узлов и
//количества замкнутых независимых контуров
//А именно(рёбра и узлы активные): Кол.замкн.контуров = Кол.рёбер - Кол.узлов + Кол.несвязных.цепей
//								   Кол.уравнений.баланса.в.узлах = Кол.узлов - Кол.несвязных.цепей
//								   Ранг = Кол.замкн.контуров + Кол.уравнений.баланса.в.узлах = Кол.рёбер
offset = 0;    //сдвиг нумерации инициализируется нулём

for (j = 0; j < Rebro_kol; j++)  //перебор по всем индексам необработанной матрицы (идём сначала по столбцам)
{
	//если ребро отключено - пропуск стобца, инкримент сдвига нумерации
	if(kluch_kombo[j] == 0) {offset++; continue;}
	//иначе переписываем данные столбца в обработанную матрицу со сдвигом нумерации
	for (i = 0; i < Rebro_kol_mod; i++)
	{
		matrix_a_mod[i][j-offset] = matrix_a[i][j];
	}
}

	//--------------------------
	//переписываем данные в ветор правых частей
	//в данном методе он остаётся без изменений
	for (i = 0; i < Rebro_kol_mod; i++)
	{
		vector_b_mod[i] = vector_b[i];
	}
	//--------------------------
	//вызов решателя СЛАУ
	ier = Solve_lin_system(Rebro_kol_mod, vector_b_mod, matrix_a_mod, vector_f_mod, pr_print, f);

	//--------------------------
	//запись ответа в вектор переменных
	offset = 0;  //инициализация сдвига нумерации нулём
	for (j = 0; j < Rebro_kol; j++)    //перебор по ВСЕМ рёбрам
	{
	//если ребро было отключенно, то ток в нём равен 0
	if(kluch_kombo[j] == 0) {offset++; vector_f[j] = (double) 0.0; continue;}
	//в остальных случаях переписываем данные со сдвигом
	vector_f[j] = vector_f_mod[j-offset];
	}

//--------------------------
//удаление созданных обработанных массивов
for (i = 0; i < Rebro_kol_mod; i++)
{
	delete matrix_a_mod[i];
}
delete matrix_a_mod;
delete vector_b_mod;
delete vector_f_mod;

//--------------------------
//возврат номера ошибки
return ier;
}  //конец функции создания и решения СЛАУ
